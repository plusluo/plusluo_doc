# OpenClaw 技术调研报告

> 作者：plusluo
> 版本：2026.02.26
> 目标读者：产品经理、技术管理者

---

## 一、OpenClaw 是什么？

### 1.1 一句话定义

OpenClaw 是一个**开源的本地 AI 助手平台**——通过一个统一的 Gateway（网关）控制平面，将 AI Agent 能力投射到用户已有的 WhatsApp、Telegram、Slack、企业微信等 15+ 消息平台上，让 AI 像一个**"数字员工"**一样替用户执行实际任务（文件操作、Shell 命令、浏览器控制、日程管理等），而且记得住你的习惯和偏好。

### 1.2 通俗理解

| 传统 Chatbot | OpenClaw |
|-------------|----------|
| 只能对话，"有嘴没手" | 能对话，也能执行操作——"有嘴有手有脑" |
| 每次对话都是新的，不记得你是谁 | 记得你的名字、偏好、历史任务 |
| 只能在一个平台（比如网页）使用 | 同时接入微信、Telegram、Slack 等 15+ 平台 |
| 你问一句它答一句 | 能主动提醒、定时执行、后台巡检 |

**形象比喻**：传统 Chatbot 像一个只会接电话的客服；OpenClaw 像一个配了电脑、日程表和记事本的全职秘书。

### 1.3 与同类 Agent 产品的区别

> **说明**：这里对比的都是"能替你干活"的 Agent 形态产品，而非 ChatGPT、DeepSeek 等纯大模型对话工具。纯大模型是 Agent 的"大脑引擎"，Agent 产品则是在大模型之上加了"手脚、记忆和调度系统"的完整解决方案。

| 对比维度 | Manus | Claude Cowork | OpenClaw |
|---------|-------|---------------|----------|
| **定位** | 云端通用 Agent（闭源） | 云端桌面 Agent（闭源） | 本地开源 AI 助手平台 |
| **开源** | ❌ 闭源（需邀请码） | ❌ 闭源 | ✅ 完全开源（MIT 许可证） |
| **运行环境** | 云端虚拟机 | 云端沙箱 | 你自己的电脑（本地优先） |
| **数据隐私** | 数据在云端 | 数据在 Anthropic 服务器 | 数据完全在本地，用户可控 |
| **操作能力** | 云端虚拟机操作（文件、浏览器） | 一键整理桌面、创建文档、数据分析 | 直接操控本机（文件、浏览器、终端、日程等） |
| **消息平台** | 仅自有网页 | 仅自有网页 | 15+ 平台（微信、Telegram、Slack、Discord…） |
| **主动行为** | 只能被动回答 | 只能被动回答 | 有"心跳"机制，能主动巡检、定时提醒 |
| **记忆系统** | 无跨会话记忆 | 有限的项目记忆 | 三层记忆（短期+长期+人格画像），跨会话不遗忘 |
| **可定制性** | 不可定制 | 不可定制 | 52 个内置技能 + 5000+ 社区技能，可自由扩展 |
| **大模型支持** | 绑定自有模型 | 绑定 Claude 模型 | 可接入任意大模型（Claude、GPT、DeepSeek、Kimi…） |

**核心差异**：Manus 和 Claude Cowork 都是"云端租一台虚拟电脑给 AI 用"，而 OpenClaw 是"让 AI 直接在你自己的电脑上干活"。前者更像远程代办，后者更像身边的全职助理。

### 1.4 行业影响力

**GitHub Stars**：120,000+（截至 2026 年 2 月）

**市场效应**：OpenClaw 发布（2026 年 1 月 24 日）后，全球 LLM Token 调用量出现突然加速：

| 月份 | 月调用量 | 环比增长率 | 备注 |
|------|---------|----------|------|
| 2025-11 | 10.5 T | 28.0% | |
| 2025-12 | 13.0 T | 23.8% | |
| **2026-01** | **24.0 T** | **84.6%** | **OpenClaw 发布（1月24日）** |
| 2026-02 | 31.5 T | 31.3% | |

### 1.5 各大厂跟进情况

| 公司 | 核心动作 |
|------|---------|
| **OpenAI** | 招入 OpenClaw 创始人，将其 GUI 操控能力整合为 ChatGPT 原生 Agent 核心 |
| **Anthropic** | 2026 年 1 月发布 Claude Cowork，云端桌面 Agent，可一键整理桌面、创建文档、分析数据 |
| **Google** | Gemini 3 推出"Yolo Mode"（自动确认模式），利用 100 万+ 上下文作为长程记忆库 |
| **Microsoft** | Copilot 引入"Heartbeat"机制模仿主动 Agent 行为 |
| **DeepSeek** | 社区首选高性价比引擎，官方提交多个 PR 优化 JSON Mode 以适配 OpenClaw |
| **阿里** | 阿里云上线一键部署模板，钉钉实现官方连接 |
| **百度** | 借鉴 OpenClaw 的 GUI 控制逻辑，结合"红手指"云手机，做移动版 Agent |
| **字节** | 火山引擎优化豆包调用延迟，推出"豆包 Agent 开放市场"对标 ClawHub 技能市场 |
| **智谱** | 与电脑厂商合作推出"GLM-Agent 盒子"，AutoGLM 架构与 OpenClaw 协议互通 |
| **华为** | 华为云发布官方加固版镜像，适配鸿蒙系统的远程控制接口 |
| **阶跃星辰** | 2025 年 9 月发布"阶跃 AI 桌面伙伴（小跃）"，国内最早的桌面 Agent 之一 |

### 1.6 重点关注：Kimi 与 MiniMax 的 Agent 化布局

这两家国内厂商的动作最为激进，且与 OpenClaw 生态直接打通，值得重点关注：

#### Kimi（月之暗面）—— 三步走，从模型到 Agent 平台

| 时间 | 动作 | 说明 |
|------|------|------|
| 2025 年底 | 发布 Kimi K2 模型并开源 | 总参数 1T、激活参数 32B 的 MoE 架构模型，专门强化了代码能力和 Agent 工具调用能力，接入 Perplexity 平台，与 GPT-5.1 同批次 |
| 2026 年 2 月 | 上线 **Kimi Claw Beta** | 原生集成 OpenClaw 生态，可在浏览器标签页中直接运行，支持一键调用 ClawHub 5000+ 社区技能，提供 40GB 云存储，用户也可将自己的 OpenClaw 实例接入 kimi.com |
| 2026 年 2 月 | 发布 **OK Computer** Agent 模式 | 基于端到端训练的 K2 模型，延续"模型即 Agent"理念。用户下达需求后，Kimi 操作自身的虚拟电脑，可自主完成网站开发、海量数据分析、图片视频生成、PPT 制作等复杂任务 |

**Kimi 的策略特点**：不只是做 OpenClaw 的接入层，而是同时自研 Agent 能力（OK Computer），形成"自研 + 开源生态"双轮驱动。据报道，Kimi 新模型发布后全球付费用户增长 4 倍，海外收入已超过国内，定位为"Anthropic + Manus"的综合体。

#### MiniMax —— MaxClaw 一键部署，做 OpenClaw 的"精装房"

| 时间 | 动作 | 说明 |
|------|------|------|
| 2026 年 2 月初 | 上线桌面 Agent | 能接管本地环境，操作本地文件和软件，积累长期记忆 |
| 2026 年 2 月 26 日 | 推出 **MaxClaw** 模式 | 基于 OpenClaw 构建的云端 AI 助手，直接集成在 MiniMax Agent 网页端，用户无需自备服务器或 API Key，一键调用 OpenClaw 核心能力 |
| 同步 | 发布 **Expert 2.0** 生态 | 用户只需用自然语言描述任务目标，Agent 自动完成 SOP 梳理、工具编排与能力配置，已有 10000+ 垂直领域专家智能体 |

**MiniMax 的策略特点**：定位为 OpenClaw 的"上层网关封装"——通过云端算力完成底层部署，用户免配置、免 API 费，一键就能用。类比来说，如果 OpenClaw 是"毛坯房需要自己装修"，MaxClaw 就是"拎包入住的精装房"。同时支持接入飞书、钉钉等工作平台。

> **对我们的启示**：Kimi 和 MiniMax 的做法说明，Agent 生态的竞争已经不只是"谁的模型更强"，而是**谁能更快地把 Agent 能力包装成普通用户可用的产品形态**。这跟我们在企业微信上要做的事情高度一致——把 Agent 能力无缝嵌入用户已有的工作平台。

---

## 二、核心架构设计——它是怎么做到的？

### 2.1 核心设计理念（为什么好用）

OpenClaw 之所以让用户觉得"有生命感"，不是靠某个单一功能，而是靠**七个核心设计点**协同工作：

**设计点 1：记忆系统——从"每次都是新实习生"变成"跟了你很久的老管家"**

> 传统 AI 每次对话都从零开始。OpenClaw 有三层记忆：
> - **短期记忆**（当前对话内容）：聊太久自动浓缩摘要，不会"脑容量溢出"
> - **长期记忆**（跨会话知识库）：你说过的偏好、项目信息，几天后还能精准召回
> - **人格画像（SOUL）**：AI 的"性格说明书"——知道该简洁还是详细、该主动还是被动，而且可以进化
>
> **举例**：第 1 天你说"以后周报用表格格式"，第 5 天你说"帮我写周报"，它自动用表格——不需要你再交代。

**设计点 2：有手有脚——不只是聊天，能替你操作电脑**

> 传统 AI 只能回答问题。OpenClaw 有 50+ 内置工具：
> - 读写文件、执行命令、操控浏览器（像人一样打开网页、点击按钮、填写表单）
> - 发送消息到各平台、创建定时任务、搜索互联网
>
> **举例**：你说"帮我在 GitHub 上给某个项目点 star"，AI 自动打开浏览器→找到按钮→点击完成。

**设计点 3：Gateway 网关——一个 AI 同时服务多个平台**

> 传统做法是每个平台各做一个 AI 机器人。OpenClaw 用一个统一的"网关"把所有平台连起来：
> - 你在 Telegram 问它一个问题，在微信能接着聊
> - 不同平台的消息统一路由、统一管理
>
> **举例**：你配了 Telegram 私聊 + Discord 工作群，AI 自动识别消息来源，分别回复。

**设计点 4：主动行为——不只是等你说话，能自己找事做**

> 传统 AI 是"你问我答"。OpenClaw 有心跳巡检和定时任务：
> - **心跳**：每 30 分钟自动检查待办事项，有事主动通知你
> - **定时任务**：每天早上 9 点帮你查 GitHub 新 Issue、每周五自动提醒写周报
>
> **举例**：你说"以后每周五下午 3 点提醒我写周报"，到了时间 AI 主动发消息。

**设计点 5：无 UI 节点嵌入——AI 直接"住"在你已有的工具里**

> 传统 AI 产品都需要一个专门的界面（网页、App）。OpenClaw 完全不需要自己的 UI——它直接嵌入你已经在用的消息平台（微信、Telegram、Slack 等），**用户在哪儿聊天，AI 就在哪儿工作**。
>
> **核心洞察：在用户习惯的环境中"交互"，是渗透率的关键。** 类比智能手机对电脑的取代——手机之所以渗透率远超 PC，不是因为手机性能更强，而是因为它"在用户身边"。同理，Agent 只有嵌入到用户已有的 IM 工具中，才能实现真正的高渗透率。事实上，用户上手 OpenClaw 后做的第一件事，通常就是接入自己的 IM 应用（Telegram、微信等）。
>
> 这种"无 UI"设计的好处是：
> - **零学习成本**：用户不需要打开新的 App，在自己熟悉的聊天窗口就能指挥 AI
> - **无缝融入工作流**：AI 不是一个需要额外切换的工具，而是直接嵌入到你的日常沟通中
> - **降低推广阻力**：不需要用户安装新软件，只需要在已有平台上加一个联系人
> - **天然的消息分发能力**：IM 工具已有的群组、通知、@提醒机制，Agent 可以直接复用
>
> **举例**：你在企业微信群里 @AI 助手说"帮我查一下上周的销售数据"，AI 直接在群里回复结果——不需要打开任何其他界面。
>
> **对企微的借鉴意义**：这恰恰是我们最应该学习的模式——AI 能力不需要独立的 App 承载，直接作为企业微信中的一个"智能联系人"存在，用户在聊天场景中自然地使用 AI 能力。**企业微信作为国内最大的企业 IM，天然具备这个优势——我们的 Agent 不需要自建渠道，直接嵌入企微就能触达数亿用户。**

**设计点 6：本地优先——在用户自己的电脑上"运行"**

> 几乎所有竞品（Manus、Claude Cowork、MaxClaw）都是"云端优先"——你的数据上传到别人的服务器，AI 在云端执行。OpenClaw 反其道而行：**一切默认在本地运行**。
>
> **核心洞察：在用户自己的电脑上运行，能够获取用户自己的权限和数据，可做事情的范围大幅扩大。** 云端 Agent 只能操作云端沙箱里的虚拟环境，而本地 Agent 能直接访问：
> - 你的本地文件系统（文档、代码、图片、配置文件）
> - 你的浏览器（包括已登录的 Cookie 和 Session，无需重复登录）
> - 你的终端和本地开发环境（git、npm、python 等）
> - 你的系统设置和已安装的应用程序
> - 你的网络环境（包括内网资源、VPN 后的服务）
>
> 本地优先还意味着：
> - **数据隐私**：你的文件、对话记录、个人偏好全部存在自己电脑上，不经过任何第三方
> - **离线可用**：搭配本地模型（如 Ollama），断网也能用
> - **完全可控**：用户可以直接查看、编辑、备份所有数据（都是 Markdown 文件和 JSONL 日志）
> - **企业合规**：敏感数据不出内网，天然满足数据安全要求
>
> **举例**：你让 AI"帮我把桌面上的合同 PDF 转成 Word，然后发给法务部张总"——云端 Agent 做不到（它访问不到你的桌面文件），但本地 Agent 可以直接读取文件→转换格式→通过 IM 发送，一气呵成。
>
> **对企微的借鉴意义**：企业客户对数据安全极为敏感。"本地优先"的架构思路意味着我们可以让 Agent 能力部署在客户端侧或企业内网，数据不出域，这是打动企业客户的关键卖点。**更重要的是，客户端 Agent 能获取用户本地的权限和上下文（通讯录、文档、日程等），做到云端 Agent 做不到的事情——这是企微客户端 Agent 相比纯 SaaS 方案的天然优势。**

**设计点 7：自进化能力——AI 会自己"长大"**

> 传统 AI 是静态的——你买来什么样，它就一直是什么样。OpenClaw 的 AI 具备**三种自进化能力**：
>
> - **记忆进化**：AI 在与用户交互中自动提炼经验教训，写入长期记忆。用得越多，它越了解你的习惯和偏好
> - **人格进化**：SOUL.md（性格说明书）不是写死的，AI 可以根据反馈自主更新自己的行为准则。比如你多次要求"回复简短一点"，AI 会把这条规则写入自己的 SOUL 文件
> - **技能进化**：AI 可以通过内置的"技能创建器"自己创建新技能。遇到重复性任务时，AI 会把操作流程封装成一个可复用的技能
>
> **举例**：你让 AI 帮你生成周报 5 次后，AI 自动总结出一个"周报生成技能"，以后一句话就搞定，还会记住你喜欢的格式、常用的模板、甚至你的写作风格。
>
> **对企微的借鉴意义**：这意味着 Agent 不只是一个工具，而是一个**越用越好用的智能伙伴**。如果企微 AI 助手也具备自进化能力，用户的迁移成本会极高（"换一个 AI 助手又要从头教"），这是用户粘性的终极壁垒。

### 2.2 整体架构总览

整个系统分为**四层**，从用户到底层依次是：

```
┌─────────────────────────────────────────────────────────────┐
│                     ① 用户交互层                              │
│  微信  Telegram  Discord  Slack  WhatsApp  飞书  iMessage …  │
│  (通过"通道插件"接入，每个平台一个插件，新增平台只需写插件)      │
└────────────────────────────┬────────────────────────────────┘
                             │
┌────────────────────────────┼────────────────────────────────┐
│                     ② 核心控制层（Gateway 网关）               │
│                                                              │
│   消息路由：来自哪个平台→交给哪个 Agent→属于哪个会话           │
│   会话管理：创建、加载、持久化会话                              │
│   心跳巡检：定时唤醒 Agent 检查待办                            │
│   定时任务：按 cron 表达式周期执行任务                          │
│   安全认证：Token/密码/VPN 等多种认证方式                      │
│   配置热重载：改配置不用重启服务                                │
└────────────────────────────┬────────────────────────────────┘
                             │
┌────────────────────────────┼────────────────────────────────┐
│                     ③ Agent 执行层（AI 的大脑和手脚）          │
│                                                              │
│   Pi Agent 引擎：核心推理循环（用户指令→LLM 思考→调用工具→     │
│                    返回结果→继续思考→直到任务完成）              │
│   50+ 内置工具：读写文件、执行命令、浏览器操控、网页搜索...     │
│   52 个内置技能 + 5000+ 社区技能                               │
│   安全审批：危险命令需用户确认才能执行                          │
└────────────────────────────┬────────────────────────────────┘
                             │
┌────────────────────────────┼────────────────────────────────┐
│                     ④ 记忆与上下文工程                          │
│                                                              │
│   上下文工程：Prompt-based convention，用提示词约定驱动 Agent    │
│   短期记忆：当前会话上下文，超长自动摘要压缩                    │
│   长期记忆：向量数据库 + 全文检索，语义搜索召回                 │
│   人格画像：SOUL.md / IDENTITY.md / USER.md 等可进化文件       │
│   会话存档：JSONL 格式的完整对话记录                            │
└─────────────────────────────────────────────────────────────┘
```

### 2.3 三个核心价值（为什么火）

从产品角度看，OpenClaw 之所以受欢迎，本质上提供了三个核心价值：

**核心价值 1：提示词 + 运行时框架 + 基于文件的上下文 + 记忆管理，大幅降低使用门槛**

> OpenClaw 的一大创新是**用"提示词约定"代替"代码强制"**。很多传统 Agent 框架需要开发者写大量代码来管理上下文、调度工具、处理记忆。OpenClaw 用一套"提示词 + Markdown 文件 + 运行时框架"的组合拳搞定了这一切：
>
> - **AGENTS.md** 告诉 LLM "启动时应该读取最近两天的日志"——不是代码自动加载，而是 LLM 看到指令后自己调用 read 工具（Prompt-based convention，基于提示词的约定）
> - **SOUL.md / USER.md / MEMORY.md** 等文件直接注入 System Prompt，用人类可读的 Markdown 定义 Agent 行为
> - 运行时框架自动处理会话管理、消息路由、工具调用循环等复杂逻辑
>
> **结果**：开发类型的用户不需要深入理解 Agent 框架的内部实现，只需要编辑几个 Markdown 文件就能定制 AI 的行为——这把"玩 Agent"的门槛从"会写代码"降到了"会写文档"。

**核心价值 2：针对大量应用提供消息对接插件，并引导更多应用开放 Skill 生态**

> OpenClaw 不只是自己做工具，更重要的是**构建了一个开放的能力生态**：
>
> - **消息通道层**：为 15+ 主流消息平台提供了现成的对接插件，新增平台只需写一个插件
> - **Skill 生态**：通过 ClawHub 技能市场，引导了 5000+ 社区技能的生产，覆盖编程、办公、数据分析、社交媒体等各类场景
> - **工具标准化**：采用标准化的 Skill 注册协议，第三方开发者可以方便地将自己的应用能力封装成 Skill 接入 OpenClaw
>
> **结果**：OpenClaw 不只是一个 Agent 产品，更像一个"Agent 应用商店"——它的能力边界不取决于自己做了多少工具，而取决于生态中有多少参与者。这种模式让 Agent 的能力实现了指数级增长。

**核心价值 3：用户数据本地存放，过程数据（尤其密码类）存放本地，信息安全更受认可**

> 这是 OpenClaw 相比所有云端 Agent（Manus、Claude Cowork、MaxClaw）最直接的差异化：
>
> - **用户的记忆数据**（偏好、习惯、历史对话）存放在用户本地
> - **运行过程数据**（工具调用日志、中间结果）存放在用户本地
> - **用户自有的数据**（文件、文档、代码）始终在本地处理，不上传云端
> - **敏感信息（API Key、密码等）**：环境变量自动脱敏，沙箱内替换为 `***`，运行时只在本机内存中解密
>
> **结果**：用户不再需要对数据做额外的脱敏或隔离处理，"数据就在我自己电脑上"这一点本身就是最强的安全感。尤其是企业用户，数据合规天然满足。

### 2.4 关键创新点小结

| 创新点 | 说明 | 竞品是否具备 |
|--------|------|-------------|
| 三层记忆系统（短期+长期+SOUL人格） | AI 跨会话记住偏好，还能自我进化性格 | Manus/Cowork 无 SOUL，Kimi OK Computer 仅有项目记忆 |
| Gateway 统一网关 | 一个 AI 服务 15+ 平台，消息路由精确分发 | Manus/Cowork 仅自有平台，MiniMax MaxClaw 支持飞书钉钉 |
| 心跳巡检 + 定时任务 | AI 主动执行，不只是被动回答 | 阶跃"小跃"有定时任务，其余竞品均无 |
| 本地优先 | 数据在用户自己机器上，隐私可控 | Manus/Cowork/MaxClaw 数据均在云端 |
| 文件即数据库 | 用人类可读的 Markdown 文件做记忆存储 | 竞品多用不透明数据库 |
| 50+ 工具 + 5000+ 技能市场 | Agent 能力可无限扩展 | Kimi Claw 已打通 5000+ ClawHub 技能，其余竞品较少且不可扩展 |

---

## 三、分层架构详解——从用户说话到 AI 回复的全过程

### 3.1 用户交互层——15+ 平台统一接入

这一层解决的问题是：**不同消息平台的 API 千差万别，如何让 AI 不用关心"消息从哪来"？**

OpenClaw 的做法是"通道插件"模式——每个平台写一个适配插件，向上提供统一接口：

- 已支持 8 个核心平台：Telegram、WhatsApp、Discord、Slack、Signal、iMessage、Google Chat、IRC
- 另有 10+ 社区扩展：飞书、钉钉、Microsoft Teams、Line、Matrix 等
- **新增平台只需写一个插件，不用改核心代码**

各主流消息平台对接适配性评估：

| 消息平台 | 多 Agent 路由支持 | 语音消息 |
|----------|-----------------|---------|
| Telegram | 最好（S 级）——同一群可多 Bot 并存 | 支持 |
| Discord | 较好（A 级）——可连接多 Bot | 部分支持 |
| Slack | 好（A+ 级）——可同频道多 Bot | 不适配 |
| WhatsApp | 中等（B+ 级） | 支持 |
| 企业微信 | 较难实现（B 级） | 不适配 |
| 飞书 | 较难实现（B 级） | 不适配 |
| 钉钉 | 较难实现（B 级） | 不适配 |

### 3.2 核心控制层（Gateway）——系统的调度中枢

Gateway 是整个系统的"大脑"，负责四件核心事情：

#### 3.2.1 消息路由——"来信分拣员"

当一条消息进来时，路由层按 8 级优先级决定交给谁处理：

```
一条 Telegram 消息到达
→ 它来自哪个平台？（Telegram）
→ 来自哪个用户？（user123）
→ 是私聊还是群聊？（私聊）
→ 匹配到哪个 Agent？（主 Agent）
→ 属于哪个会话？（agent:main:telegram:direct:user123）
→ 交给该会话处理
```

**举例**：你配了 Agent A 管工作群、Agent B 管私聊。群里的消息自动交给 A，私聊的交给 B，互不干扰。

#### 3.2.2 会话管理——对话的"上下文记录本"

每个用户在每个渠道上都有独立的会话，会话中保存了完整的对话历史。会话管理负责：创建新会话、加载历史会话、持久化保存（JSONL 格式 + 元数据文件）、会话清理。

#### 3.2.3 心跳巡检——"AI 的生物钟"

每 30 分钟自动唤醒 AI，让它检查工作区的 `HEARTBEAT.md` 文件，看有没有待办事项。

**举例**：你在 `HEARTBEAT.md` 中写了"检查 GitHub 是否有新 PR 需要 review"，AI 每 30 分钟自动检查一次，有新 PR 就通知你。没有任务时自动回复"一切正常"，不消耗额外资源。

#### 3.2.4 定时任务——"AI 的日程表"

支持三种调度方式：
- **一次性**：明天下午 3 点提醒我开会
- **固定间隔**：每 30 分钟检查一次邮件
- **Cron 表达式**：每周五 18:00 生成周报

### 3.3 Agent 执行层——AI 的"大脑和手脚"

这一层是 AI 真正"干活"的地方。

#### 3.3.1 Agent 引擎——Pi Agent

OpenClaw 的核心创新之一是**不重新发明 Agent 引擎**，而是将开源的 Pi Coding Agent 作为嵌入式 SDK 集成。Pi 负责"思考"（LLM 推理 + 工具调用循环），OpenClaw 负责"一切上层能力"（路由、安全、记忆、多渠道等）。

**这种设计的好处**：Pi 引擎升级时，OpenClaw 自动获得改进；OpenClaw 团队专注于差异化能力，不用重复造轮子。

#### 3.3.2 工具体系——Agent 能干什么？

8 个最核心的工具：

| 工具 | 作用 | 通俗说明 |
|------|------|---------|
| **exec** | 执行命令 | 像你在终端里敲命令一样，Agent 能运行任何程序 |
| **browser** | 浏览器操控 | 像你用鼠标一样，Agent 能打开网页、点击、输入、截图 |
| **web_search** | 联网搜索 | Agent 不再只靠训练数据，能实时搜索互联网 |
| **memory** | 语义记忆 | Agent 能跨会话记住你的偏好和历史 |
| **message** | 多平台消息 | Agent 能主动在 21 个平台上发消息 |
| **cron** | 定时任务 | Agent 能按计划自动执行任务 |
| **subagents** | 多 Agent 协作 | 主 Agent 能拆分任务给子 Agent 并行处理 |
| **image** | 图像理解 | Agent 能"看懂"截图、图表、照片 |

**举例**：你说"帮我查一下某网站的价格，跟上次比是涨了还是跌了"——Agent 会用 `browser` 打开网站→用 `memory` 找到上次的价格记录→对比后回复你。

#### 3.3.3 工具扩展性——Shell 编程指令 + Skill 的双层扩展机制

OpenClaw 的工具扩展性是其架构中极为关键的设计，采用了**"内置工具 + Shell 编程 + Skill 注册"的混合范式**：

```
┌─────────────────────────────────────────────────────────┐
│                  工具执行混合范式                          │
│                                                          │
│  第一层：First-class Tools（内置工具）                     │
│  → 采用标准 function call 保障稳定性                      │
│  → exec / browser / memory 等核心能力                     │
│  → 与 LLM 的工具调用协议紧密绑定                          │
│                                                          │
│  第二层：Shell 编程执行（扩展性关键）                      │
│  → 通过 exec 工具执行任意 Shell 命令                      │
│  → 支持 Python、Node.js、Bash 等脚本即时编写和运行        │
│  → Agent 可以"现写现用"——遇到新需求直接编程解决            │
│  → 这赋予了 Agent 理论上无限的能力边界                     │
│                                                          │
│  第三层：Skill 标准化注册                                  │
│  → 可动态引入第三方自定义工具                              │
│  → 采用 ReAct 方式进行工具执行（最多 20 轮推理-行动循环）  │
│  → 通过标准化协议封装，社区可贡献和复用                    │
│                                                          │
│  安全保障：                                                │
│  → Schema 检查 + 多层策略筛选 + Docker 沙箱隔离           │
│  → 限制文件/网络访问范围                                   │
└─────────────────────────────────────────────────────────┘
```

> **这也是 OpenClaw 选择基于 Pi Agent 进行改造的重要原因之一**：Pi 作为一个 Coding Agent，天然具备强大的代码生成和 Shell 执行能力。OpenClaw 在 Pi 的基础上加入了 Skill 注册协议和安全沙箱，使得**"Shell 编程指令"成为了工具扩展的万能接口**——任何能用代码解决的问题，Agent 都可以通过编写脚本来完成；而对于高频和成熟的操作，则封装成 Skill 供复用。

#### 3.3.4 技能市场——可以无限扩展的能力

工具是原子能力（"手指能做什么动作"），技能是组合能力（"教手指弹一首曲子"）。

- **52 个内置技能**：编程助手、GitHub 管理、邮件管理、Notion 集成、可视化画布等
- **5000+ 社区技能**：通过 ClawHub 技能市场安装，一行命令搞定（Kimi Claw 已全量打通这个生态）
- **技能创建器**：AI 可以帮你创建新技能

### 3.4 记忆与上下文工程——OpenClaw 最精妙的设计

这是 OpenClaw 最有特色的设计之一，也是它"生命感"的根基。这一层不只是"存数据"，更是一套完整的**上下文工程（Context Engineering）**体系。

#### 3.4.1 上下文工程——用"提示词约定"编排 Agent 行为

传统 Agent 框架通过代码逻辑硬编码来管理上下文（什么时候加载什么数据、如何组装 System Prompt 等），OpenClaw 独创了一种**"Prompt-based Convention"（基于提示词的约定）**方式：

> **核心思路**：不是靠代码自动化，而是**靠提示词告诉 LLM 该做什么**——LLM 读到指令后，自己调用工具完成操作。

具体来说，OpenClaw 的上下文构建流程如下：

```
┌─────────────────────────────────────────────────────────┐
│                   System Prompt 组装                      │
│                                                          │
│  ① IDENTITY.md  →  注入 Agent 身份（名字、形象）          │
│  ② SOUL.md      →  注入行为准则（价值观、风格）           │
│  ③ USER.md      →  注入用户信息（偏好、习惯）             │
│  ④ TOOLS.md     →  注入工具使用笔记                       │
│  ⑤ MEMORY.md    →  注入抽象经验和教训                     │
│  ⑥ AGENTS.md    →  注入工作规范（含上下文加载指令）        │
└──────────────────────────┬──────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│              AGENTS.md 中的上下文指令（关键！）            │
│                                                          │
│  "启动时读取最近 2 天的 daily notes"                      │
│  "每次对话开始前，检查 HEARTBEAT.md 中的待办事项"          │
│  "遇到用户提问时，先搜索 MEMORY.md 中的相关记忆"          │
│  "任务完成后，将关键信息写入对应的记忆文件"                │
│                                                          │
│  ↑ 这些不是代码逻辑，而是 LLM 看到后自己执行的指令        │
└──────────────────────────┬──────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│                 LLM 执行上下文加载                         │
│                                                          │
│  LLM 看到 AGENTS.md 中的指令后：                          │
│  → 自己调用 read 工具读取 daily notes                     │
│  → 自己调用 memory_search 工具检索相关记忆                │
│  → 自己决定哪些上下文需要加载                              │
│  → 将加载的信息融入本次对话的上下文                        │
└─────────────────────────────────────────────────────────┘
```

**这种设计的精妙之处在于**：

| 传统方式（代码驱动） | OpenClaw 方式（提示词驱动） |
|---------------------|--------------------------|
| 开发者写代码定义"什么时候加载什么上下文" | 在 AGENTS.md 中用自然语言写"你应该做什么" |
| 修改行为需要改代码、重新部署 | 修改行为只需编辑 Markdown 文件 |
| 上下文加载逻辑固定、不灵活 | LLM 可根据场景灵活判断是否需要加载 |
| 开发门槛高（需要懂框架 API） | 使用门槛低（只需要会写文档） |

> **举例**：你在 AGENTS.md 中写"如果用户问到项目相关的问题，先读取 ~/projects/ 目录下的 README.md 获取项目背景"——LLM 看到这条规则后，当用户问到项目问题时会**自己调用文件读取工具**去获取背景信息，而不需要任何代码逻辑来触发这个行为。

**对企微的借鉴意义**：这种"上下文工程"的方式意味着，Agent 的行为定制可以不依赖开发者——运营人员甚至企业管理员都可以通过编辑配置文件来调整 AI 助手的行为。这对企业场景的快速落地和个性化定制至关重要。

#### 3.4.2 三层记忆协作机制

| 记忆层 | 通俗比喻 | 作用 | 举例 |
|--------|---------|------|------|
| **短期记忆** | 脑子里的便签 | 记住当前对话，聊太久自动浓缩 | 记住今天下午刚说的"紧急客诉" |
| **长期记忆** | 带索引的笔记本 | 跨会话保存知识，语义搜索召回 | 5 天后还能翻到"用表格格式写周报" |
| **人格画像（SOUL）** | 性格说明书 | 定义 AI 的风格和行为边界，可自我进化 | 知道该简洁直接，周五主动提醒 |

#### 3.4.3 人格画像文件体系

| 文件 | 内容 | 何时加载 |
|------|------|---------|
| IDENTITY.md | Agent 的名字、形象 | 每次对话 |
| SOUL.md | 价值观、行为准则 | 每次对话 |
| USER.md | 用户信息与偏好 | 每次对话 |
| AGENTS.md | 工作规范、协作规则 | 每次对话 |
| TOOLS.md | 工具使用笔记 | 每次对话 |
| MEMORY.md | 抽象经验、教训 | 仅主会话 |

**关键设计**：这些文件都是**人类可读的 Markdown**，用户可以直接编辑来定制 AI 行为。

#### 3.4.4 记忆检索技术

采用**向量语义搜索 + 全文检索**的混合策略：
- 向量搜索：理解语义（"编程语言偏好"能匹配到"我喜欢用 TypeScript"）
- 全文搜索：精确匹配关键词
- MMR 去重：避免返回重复的记忆
- 时间衰减：最近的记忆权重更高

### 3.5 一个完整案例：从用户指令到最终输出

**场景：用户在 Telegram 发送"帮我写一个 Python 脚本，把本周的工作整理成周报"**

```
第 1 步：Telegram 通道插件收到消息
    ↓
第 2 步：Gateway 网关接收 → 认证检查（确认是合法用户）
    ↓
第 3 步：路由层解析
    → 来源：Telegram 私聊 user123
    → 目标：主 Agent
    → 会话：agent:main:telegram:direct:user123
    ↓
第 4 步：会话管理加载历史对话上下文
    ↓
第 5 步：记忆系统检索
    → 搜索"周报"相关记忆
    → 找到：用户偏好"表格格式、双栏"（5 天前记录的）
    → 找到：本周的工作记录（从日志中提炼的）
    ↓
第 6 步：构建完整提示词
    → 系统提示（身份+技能+安全规则）
    → SOUL.md（性格：简洁直接）
    → USER.md（用户偏好）
    → 检索到的记忆
    → 用户当前消息
    ↓
第 7 步：Agent 执行循环
    → LLM 思考 → 决定先读取本周的文件记录
    → 调用工具：read（读取工作记录）
    → LLM 继续思考 → 决定写脚本
    → 调用工具：write（创建 Python 脚本）
    → 安全审批：检查命令是否在白名单
    → 调用工具：exec（运行脚本，生成周报）
    → LLM 生成最终回复
    ↓
第 8 步：出站投递
    → 格式化回复 → 长消息自动分片 → 通过 Telegram API 发送
    ↓
第 9 步：用户在 Telegram 收到回复
    → "根据你的习惯，我用表格格式整理了周报：..."
    → 附带生成的周报文件
```

---

## 四、对话流畅性保障——为什么用起来不卡顿

OpenClaw 设计了三层机制确保对话自然流畅：

### 4.1 消息防抖——等你"说完"再处理

**问题**：用户经常分多条消息表达一个意思。

```
14:30:01 "帮我写一个函数"
14:30:02 "用 Python"
14:30:04 "要带类型注解的"
```

**解决**：系统自动等待一个"静默窗口"（默认 2 秒），把多条消息合并成一条再交给 AI：
```
合并后 → "帮我写一个函数\n用 Python\n要带类型注解的"
```
AI 一次性处理，而非 3 次分别回复。

### 4.2 Steer 指令注入——AI 干活时你可以"改口"

**问题**：AI 正在执行任务，你突然改了需求。

```
你："帮我写一个冒泡排序"
AI：正在写冒泡排序...
你："算了，改用快排"    ← AI 还在忙
```

**解决**：新指令直接"插队"注入到 AI 当前的对话中，AI 立即看到并调整方向，不用等它写完冒泡排序再重来。

### 4.3 语音端点检测——判断你"话说完了"

**问题**：语音场景中，用户说话有自然停顿，系统需要判断"是在思考还是说完了"。

**解决**：根据不同场景设置不同的静音阈值——电话场景 0.8 秒、Discord 语音 1 秒、macOS 语音唤醒 2 秒——在"反应灵敏"和"不误截断"之间取平衡。

---

## 五、安全机制——AI 有执行能力，如何防止它"闯祸"

由于 Agent 能执行命令、操控浏览器、访问文件，安全是重中之重。OpenClaw 构建了**九层安全纵深防御**：

| 层次 | 防什么 | 怎么防 | 举例 |
|------|--------|--------|------|
| 认证层 | 未授权访问 | 多种认证模式 + 暴力破解锁定 | 连续错 10 次密码→锁定 5 分钟 |
| 网络层 | 内网渗透（SSRF） | 两阶段 DNS 检查，阻断私有 IP 访问 | AI 被诱导访问 192.168.1.1→拦截 |
| 命令审批层 | 危险命令执行 | 三级策略（禁止/白名单/全放行）+ 远程审批 | AI 要执行 rm -rf→手机推送让你确认 |
| 沙箱层 | 容器逃逸 | Docker 硬化 + 路径黑名单 + 环境变量脱敏 | API Key 自动替换为 *** |
| 工具门控层 | 敏感工具滥用 | 危险工具黑名单 + 按场景限制 | HTTP 接口禁止调用定时任务工具 |
| 文件安全层 | 路径穿越攻击 | 路径检查 + 符号链接检测 | 访问 ../../etc/passwd→拦截 |
| 代码扫描层 | 恶意第三方技能 | 7 种静态分析规则 | 技能偷读 API Key→安装时告警 |
| 输入清洗层 | 提示注入 | 外部内容安全边界标记 | 恶意邮件指令→标记为外部内容，不执行 |
| 审计层 | 事后追溯 | 全面安全审计 + 日志记录 | 自动检查配置是否存在安全风险 |

---

## 六、并发与调度——多人同时使用怎么办

### 6.1 会话泳道（Command Lanes）

OpenClaw 用"泳道"机制管理并发：

- **Session Lane**：同一用户的请求串行执行（防止同时改一个文件出错）
- **Global Lane**：跨用户可并行，但限制同时调用 LLM 的总数（防止超过 API 限速）
- **独立 Lane**：定时任务、子 Agent 有独立泳道，互不阻塞

**举例**：用户 A 和用户 B 同时发消息→各自的请求并行处理；但用户 A 连发 3 条→按先后排队串行处理。

### 6.2 防饥饿机制

防止某些任务"永远排不上队"的多种策略：严格 FIFO（先来先服务）、每用户独立队列、有界队列溢出摘要、API Key 轮换均匀分配、故障自动恢复等。

---

## 七、对企业微信的借鉴：Agent 架构为什么值得投入？

### 7.1 核心结论

通过深入分析 OpenClaw 的架构，以及 Kimi、MiniMax、阶跃星辰等国内厂商的快速跟进，可以清晰看到一个行业共识正在形成：**AI 产品的竞争已从"模型能力"转向"Agent 架构"**。以下是对企业微信最有借鉴价值的几个方向。

**（1）Agent 架构很有必要——从"对话工具"到"智能助理"**

OpenClaw 证明了：AI 不应该只是"问答工具"，而应该是**能执行操作的智能助理**。它的 50+ 工具和 5000+ 技能让 AI 从"有嘴没手"变成"有嘴有手有脑"。

行业验证：
- Kimi 的 OK Computer 已经能操作虚拟电脑自主完成网站开发、数据分析、PPT 制作
- MiniMax 的桌面 Agent 能接管本地环境，操作文件和软件
- 阶跃星辰的"小跃"支持自然语言操控电脑，处理文件、爬取网页、执行脚本

**这些都说明"只会聊天"的 AI 已经不够了。我们的产品如果只停留在对话层面，竞争力会越来越弱。**

**（2）记忆系统很有必要——"用户粘性"的核心引擎**

OpenClaw 的三层记忆（短期+长期+SOUL 人格）让 AI 从"每次都是新来的实习生"变成"跟了你很久的老管家"。这种"生命感"是用户粘性的核心。

行业验证：
- MiniMax 桌面 Agent 明确强调"积累长期记忆"作为核心卖点
- 阶跃星辰"小跃"定位"有记忆、能进化"，支持记录桌面活动生成日报

**我们目前的上下文管理能力还远远不够，需要建设：**
- 多层次记忆架构（当前对话 + 天级日志 + 长期知识库 + 用户画像）
- 混合检索机制（向量语义搜索 + 关键词搜索）
- 文件即数据库的设计（简单、可读、可备份、可版本控制）

**（3）本地工具能力很有必要——Agent 部署到企微客户端的核心能力**

OpenClaw 最大的差异化不是"聊得好"，而是"做得到"——操控浏览器、执行命令、管理文件。**这恰恰是我们在企业微信客户端上最需要的能力方向**：通过 JSAPI 等半开放接口让 AI 能自动完成企业办公操作。

**客户端 Agent 的独特优势（云端 Agent 不具备的）：**

| 优势 | 说明 | 举例 |
|------|------|------|
| **获取本地权限和数据** | 可访问用户本地文件、通讯录、日程等 | 直接读取本地 Excel 做分析，不需要用户上传 |
| **复用已登录状态** | 浏览器 Cookie/Session 可直接复用 | 不需要重新登录各类内部系统 |
| **访问内网资源** | 在企业网络环境内运行 | 可直接查询内部 Wiki、OA 系统、代码仓库 |
| **零门槛使用** | 一线员工无需技术背景 | 对 AI 说一句话就能完成原子任务，无需学习任何工具 |
| **功能暴涨潜力** | AI 可自由组合 JSAPI 能力 | 一个 Agent 通过组合 JSAPI 实现成百上千种自动化操作 |

> **关键认识**：AI 可能带来新增功能数量的暴涨——我们目前尚无零门槛让一线员工使用 AI 自由调度工作、完成原子任务的能力。OpenClaw 的工具体系（尤其是 exec + browser + 文件操作的组合）证明了：**只要给 Agent 足够的工具权限，它的能力上限就是整个操作系统的能力上限。**

企微 JSAPI 可实现的 Agent 操作示例：

| 用户说 | AI 自动执行 |
|--------|-----------|
| "帮我找研发部张三的联系方式" | 搜索企业通讯录→打开用户资料 |
| "把项目方案发给王总" | 选择联系人→发送消息 |
| "建一个下周一的项目评审会议" | 创建企业会议→发送通知 |
| "新建一个项目周报表格" | 创建文档→打开编辑 |
| "把会议纪要分享到部门群" | 分享到群组 |

行业对照：MiniMax MaxClaw 已支持接入飞书、钉钉；阶跃"小跃"已能操作本地软件和填写网页表单。**这说明竞品已在"AI 接入工作平台"方向快速推进，我们不能落后。**

**（4）代码生成引擎（Pi Agent）需要重点关注**

OpenClaw 不是自己造 Agent 引擎，而是把开源的 Pi Coding Agent 作为嵌入式 SDK 集成。**选择 Pi 的核心原因是：Pi 天然具备强大的代码生成和 Shell 执行能力**，这使得 OpenClaw 的工具扩展性可以通过"Shell 编程指令 + Skill 注册"实现——任何新需求都可以通过 Agent 编写脚本来解决，高频操作再封装成可复用的 Skill。这种架构让工具体系的能力上限等同于整个编程语言的能力上限。

为什么？因为：
- 我们使用的所有 App、操作系统，本质都是代码工程
- 如果一个 Agent 足够擅长写代码和执行代码，理论上它可以完成任何软件能做的事
- OpenClaw 的 40+ 工具中，最核心的就是 `exec`（执行命令）——一个能写代码、执行代码的 Agent，能力上限极高

行业验证：
- Kimi K2 模型专门强化了代码能力和 Agent 工具调用能力，并已开源
- Kimi 定位为"Anthropic + Manus"综合体，其核心就是"模型即 Agent"——让模型本身就具备写代码和调用工具的能力

**我们目前对这类"生成代码→执行代码"的引擎关注不够。** Pi Agent 这样的开源代码引擎，以及 Claude Code、Kimi K2 等产品的理念，都值得我们深入跟进和引入。未来的 Agent OS 很可能是：**一切需求都可以被翻译成代码需求，由 Code Agent 来实现。**

**（5）"平台化封装"是落地关键——做企微上的 MaxClaw**

MiniMax 的 MaxClaw 给我们最直接的启示是：Agent 能力再强，如果普通用户用不起来也是白搭。MaxClaw 把 OpenClaw 的复杂部署简化成"一键使用"，本质是做了**上层网关封装**。

**这正是我们在企业微信上应该做的事**：把 Agent 的能力（工具调用、记忆管理、定时任务等）封装成企微用户无感知的产品体验。用户不需要知道什么是 Agent 架构、什么是记忆系统，他只需要对企微 AI 助手说一句话，事情就办好了。

### 7.2 现有 Demo 情况

| Demo | 状态 | 说明 |
|------|------|------|
| JSAPI 企微客户端 Agent | 已可演示 | 通过 vid 查用户名等实用工具 |
| WebSocket 增强版 | 可体验（未发布） | 年前对齐 WebSocket 能力后的用法 |
| 内置 OpenClaw 到企业微信 | 开发中 | 解决安装困难的内部 Demo |
| 消化 OpenClaw 能力接入企微 | 评估中 | 精简后接入的方案 |

### 7.3 总结

OpenClaw 的价值不在于某个单一功能，而在于**它用一套完整的架构证明了"AI 助手"应该长什么样**：

- 不是只会聊天的 Chatbot，而是有执行能力的 Agent
- 不是每次都从零开始，而是有记忆、有人格、越用越懂你
- 不是只在一个平台可用，而是统一接入所有你已有的工作平台
- 不是只能被动等待，而是能主动巡检、定时执行

行业的反应也验证了这一方向的正确性：Kimi 从模型到 Kimi Claw 到 OK Computer，MiniMax 从桌面 Agent 到 MaxClaw，阶跃星辰的"小跃"——**所有头部厂商都在从"做模型"转向"做 Agent 产品"**。

**我们需要从这一趋势中认识到：Agent 架构 + 记忆系统 + 本地工具能力 + Code Agent 引擎 + 平台化封装，这五个方向是我们接下来必须重点投入的。** 这不只是技术升级，更是产品形态的根本转变——从"对话工具"到"企业微信上的智能助理操作系统"。
